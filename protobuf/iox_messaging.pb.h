// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: iox_messaging.proto
// Protobuf C++ Version: 5.27.4

#ifndef GOOGLE_PROTOBUF_INCLUDED_iox_5fmessaging_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_iox_5fmessaging_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_iox_5fmessaging_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_iox_5fmessaging_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_iox_5fmessaging_2eproto;
namespace com {
namespace geotab {
namespace ioxproto {
class ClearSubsAck;
struct ClearSubsAckDefaultTypeInternal;
extern ClearSubsAckDefaultTypeInternal _ClearSubsAck_default_instance_;
class Gps;
struct GpsDefaultTypeInternal;
extern GpsDefaultTypeInternal _Gps_default_instance_;
class IoxFromGo;
struct IoxFromGoDefaultTypeInternal;
extern IoxFromGoDefaultTypeInternal _IoxFromGo_default_instance_;
class IoxToGo;
struct IoxToGoDefaultTypeInternal;
extern IoxToGoDefaultTypeInternal _IoxToGo_default_instance_;
class PubSubFromGo;
struct PubSubFromGoDefaultTypeInternal;
extern PubSubFromGoDefaultTypeInternal _PubSubFromGo_default_instance_;
class PubSubToGo;
struct PubSubToGoDefaultTypeInternal;
extern PubSubToGoDefaultTypeInternal _PubSubToGo_default_instance_;
class Publish;
struct PublishDefaultTypeInternal;
extern PublishDefaultTypeInternal _Publish_default_instance_;
class SubAck;
struct SubAckDefaultTypeInternal;
extern SubAckDefaultTypeInternal _SubAck_default_instance_;
class Subscribe;
struct SubscribeDefaultTypeInternal;
extern SubscribeDefaultTypeInternal _Subscribe_default_instance_;
class TopicInfo;
struct TopicInfoDefaultTypeInternal;
extern TopicInfoDefaultTypeInternal _TopicInfo_default_instance_;
class TopicInfoList;
struct TopicInfoListDefaultTypeInternal;
extern TopicInfoListDefaultTypeInternal _TopicInfoList_default_instance_;
class TopicList;
struct TopicListDefaultTypeInternal;
extern TopicListDefaultTypeInternal _TopicList_default_instance_;
class Unsubscribe;
struct UnsubscribeDefaultTypeInternal;
extern UnsubscribeDefaultTypeInternal _Unsubscribe_default_instance_;
class Vec3;
struct Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
}  // namespace ioxproto
}  // namespace geotab
}  // namespace com
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace com {
namespace geotab {
namespace ioxproto {
enum SubAck_Result : int {
  SubAck_Result_SUB_ACK_RESULT_UNSPECIFIED = 0,
  SubAck_Result_SUB_ACK_RESULT_SUCCESS = 1,
  SubAck_Result_SUB_ACK_RESULT_FAILED = 2,
  SubAck_Result_SUB_ACK_RESULT_UNKNOWN_TOPIC = 3,
  SubAck_Result_SUB_ACK_RESULT_TOPIC_ALREADY_SUBBED = 4,
  SubAck_Result_SUB_ACK_RESULT_TOPIC_NOT_SUBBED = 5,
  SubAck_Result_SUB_ACK_RESULT_UNAVAILABLE = 6,
  SubAck_Result_SUB_ACK_RESULT_DISABLED = 7,
  SubAck_Result_SubAck_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SubAck_Result_SubAck_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SubAck_Result_IsValid(int value);
extern const uint32_t SubAck_Result_internal_data_[];
constexpr SubAck_Result SubAck_Result_Result_MIN = static_cast<SubAck_Result>(0);
constexpr SubAck_Result SubAck_Result_Result_MAX = static_cast<SubAck_Result>(7);
constexpr int SubAck_Result_Result_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
SubAck_Result_descriptor();
template <typename T>
const std::string& SubAck_Result_Name(T value) {
  static_assert(std::is_same<T, SubAck_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return SubAck_Result_Name(static_cast<SubAck_Result>(value));
}
template <>
inline const std::string& SubAck_Result_Name(SubAck_Result value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SubAck_Result_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool SubAck_Result_Parse(absl::string_view name, SubAck_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubAck_Result>(
      SubAck_Result_descriptor(), name, value);
}
enum ClearSubsAck_Result : int {
  ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_UNSPECIFIED = 0,
  ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_SUCCESS = 1,
  ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_UNAVAILABLE = 2,
  ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_DISABLED = 3,
  ClearSubsAck_Result_ClearSubsAck_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ClearSubsAck_Result_ClearSubsAck_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ClearSubsAck_Result_IsValid(int value);
extern const uint32_t ClearSubsAck_Result_internal_data_[];
constexpr ClearSubsAck_Result ClearSubsAck_Result_Result_MIN = static_cast<ClearSubsAck_Result>(0);
constexpr ClearSubsAck_Result ClearSubsAck_Result_Result_MAX = static_cast<ClearSubsAck_Result>(3);
constexpr int ClearSubsAck_Result_Result_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ClearSubsAck_Result_descriptor();
template <typename T>
const std::string& ClearSubsAck_Result_Name(T value) {
  static_assert(std::is_same<T, ClearSubsAck_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return ClearSubsAck_Result_Name(static_cast<ClearSubsAck_Result>(value));
}
template <>
inline const std::string& ClearSubsAck_Result_Name(ClearSubsAck_Result value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ClearSubsAck_Result_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ClearSubsAck_Result_Parse(absl::string_view name, ClearSubsAck_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClearSubsAck_Result>(
      ClearSubsAck_Result_descriptor(), name, value);
}
enum Topic : int {
  TOPIC_UNSPECIFIED = 0,
  TOPIC_ACCEL = 1,
  TOPIC_GPS = 2,
  TOPIC_BATTERY_VOLTAGE = 3,
  TOPIC_VIN = 4,
  TOPIC_GEAR = 5,
  TOPIC_ENGINE_SPEED = 6,
  TOPIC_ENGINE_LOAD = 7,
  TOPIC_ODOMETER = 8,
  TOPIC_ACCEL_PEDAL_PERCENTAGE = 9,
  TOPIC_COOLANT_TEMP = 10,
  TOPIC_DOC_INTAKE_GAS_TEMP = 11,
  TOPIC_DOC_OUTLET_GAS_TEMP = 12,
  TOPIC_FUELTANK1_UNITS = 13,
  TOPIC_FUELTANK2_UNITS = 14,
  TOPIC_FUELTANK1_PERCENT = 15,
  TOPIC_FUELTANK2_PERCENT = 16,
  TOPIC_STATE_OF_CHARGE = 17,
  TOPIC_ENGINE_ROAD_SPEED = 18,
  TOPIC_VEHICLE_ACTIVE = 19,
  TOPIC_DRIVER_SEATBELT = 20,
  TOPIC_LEFT_TURN_SIGNAL = 21,
  TOPIC_RIGHT_TURN_SIGNAL = 22,
  TOPIC_EV_CHARGING_STATE = 23,
  TOPIC_PARK_BRAKE = 24,
  Topic_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Topic_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Topic_IsValid(int value);
extern const uint32_t Topic_internal_data_[];
constexpr Topic Topic_MIN = static_cast<Topic>(0);
constexpr Topic Topic_MAX = static_cast<Topic>(24);
constexpr int Topic_ARRAYSIZE = 24 + 1;
const ::google::protobuf::EnumDescriptor*
Topic_descriptor();
template <typename T>
const std::string& Topic_Name(T value) {
  static_assert(std::is_same<T, Topic>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Topic_Name().");
  return Topic_Name(static_cast<Topic>(value));
}
template <>
inline const std::string& Topic_Name(Topic value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Topic_descriptor,
                                                 0, 24>(
      static_cast<int>(value));
}
inline bool Topic_Parse(absl::string_view name, Topic* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Topic>(
      Topic_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vec3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  ~Vec3() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Vec3(
      ::google::protobuf::internal::ConstantInitialized);

  inline Vec3(const Vec3& from) : Vec3(nullptr, from) {}
  inline Vec3(Vec3&& from) noexcept
      : Vec3(nullptr, std::move(from)) {}
  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
        &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Vec3& a, Vec3& b) { a.Swap(&b); }
  inline void Swap(Vec3* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vec3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Vec3& from) { Vec3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vec3* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.Vec3"; }

 protected:
  explicit Vec3(::google::protobuf::Arena* arena);
  Vec3(::google::protobuf::Arena* arena, const Vec3& from);
  Vec3(::google::protobuf::Arena* arena, Vec3&& from) noexcept
      : Vec3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.Vec3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Vec3_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Vec3& from_msg);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class Unsubscribe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.Unsubscribe) */ {
 public:
  inline Unsubscribe() : Unsubscribe(nullptr) {}
  ~Unsubscribe() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Unsubscribe(
      ::google::protobuf::internal::ConstantInitialized);

  inline Unsubscribe(const Unsubscribe& from) : Unsubscribe(nullptr, from) {}
  inline Unsubscribe(Unsubscribe&& from) noexcept
      : Unsubscribe(nullptr, std::move(from)) {}
  inline Unsubscribe& operator=(const Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Unsubscribe& operator=(Unsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Unsubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const Unsubscribe* internal_default_instance() {
    return reinterpret_cast<const Unsubscribe*>(
        &_Unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Unsubscribe& a, Unsubscribe& b) { a.Swap(&b); }
  inline void Swap(Unsubscribe* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Unsubscribe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Unsubscribe* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Unsubscribe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Unsubscribe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Unsubscribe& from) { Unsubscribe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Unsubscribe* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.Unsubscribe"; }

 protected:
  explicit Unsubscribe(::google::protobuf::Arena* arena);
  Unsubscribe(::google::protobuf::Arena* arena, const Unsubscribe& from);
  Unsubscribe(::google::protobuf::Arena* arena, Unsubscribe&& from) noexcept
      : Unsubscribe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicFieldNumber = 1,
  };
  // .com.geotab.ioxproto.Topic topic = 1;
  void clear_topic() ;
  ::com::geotab::ioxproto::Topic topic() const;
  void set_topic(::com::geotab::ioxproto::Topic value);

  private:
  ::com::geotab::ioxproto::Topic _internal_topic() const;
  void _internal_set_topic(::com::geotab::ioxproto::Topic value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.Unsubscribe)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Unsubscribe_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Unsubscribe& from_msg);
    int topic_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class TopicList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.TopicList) */ {
 public:
  inline TopicList() : TopicList(nullptr) {}
  ~TopicList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TopicList(
      ::google::protobuf::internal::ConstantInitialized);

  inline TopicList(const TopicList& from) : TopicList(nullptr, from) {}
  inline TopicList(TopicList&& from) noexcept
      : TopicList(nullptr, std::move(from)) {}
  inline TopicList& operator=(const TopicList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicList& operator=(TopicList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicList* internal_default_instance() {
    return reinterpret_cast<const TopicList*>(
        &_TopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TopicList& a, TopicList& b) { a.Swap(&b); }
  inline void Swap(TopicList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TopicList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TopicList& from) { TopicList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.TopicList"; }

 protected:
  explicit TopicList(::google::protobuf::Arena* arena);
  TopicList(::google::protobuf::Arena* arena, const TopicList& from);
  TopicList(::google::protobuf::Arena* arena, TopicList&& from) noexcept
      : TopicList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicsFieldNumber = 1,
  };
  // repeated .com.geotab.ioxproto.Topic topics = 1;
  int topics_size() const;
  private:
  int _internal_topics_size() const;

  public:
  void clear_topics() ;
  public:
  ::com::geotab::ioxproto::Topic topics(int index) const;
  void set_topics(int index, ::com::geotab::ioxproto::Topic value);
  void add_topics(::com::geotab::ioxproto::Topic value);
  const ::google::protobuf::RepeatedField<int>& topics() const;
  ::google::protobuf::RepeatedField<int>* mutable_topics();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_topics() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_topics();

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.TopicList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TopicList_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TopicList& from_msg);
    ::google::protobuf::RepeatedField<int> topics_;
    mutable ::google::protobuf::internal::CachedSize _topics_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class TopicInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.TopicInfo) */ {
 public:
  inline TopicInfo() : TopicInfo(nullptr) {}
  ~TopicInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TopicInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline TopicInfo(const TopicInfo& from) : TopicInfo(nullptr, from) {}
  inline TopicInfo(TopicInfo&& from) noexcept
      : TopicInfo(nullptr, std::move(from)) {}
  inline TopicInfo& operator=(const TopicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicInfo& operator=(TopicInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicInfo* internal_default_instance() {
    return reinterpret_cast<const TopicInfo*>(
        &_TopicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TopicInfo& a, TopicInfo& b) { a.Swap(&b); }
  inline void Swap(TopicInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TopicInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TopicInfo& from) { TopicInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.TopicInfo"; }

 protected:
  explicit TopicInfo(::google::protobuf::Arena* arena);
  TopicInfo(::google::protobuf::Arena* arena, const TopicInfo& from);
  TopicInfo(::google::protobuf::Arena* arena, TopicInfo&& from) noexcept
      : TopicInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicFieldNumber = 1,
  };
  // .com.geotab.ioxproto.Topic topic = 1;
  void clear_topic() ;
  ::com::geotab::ioxproto::Topic topic() const;
  void set_topic(::com::geotab::ioxproto::Topic value);

  private:
  ::com::geotab::ioxproto::Topic _internal_topic() const;
  void _internal_set_topic(::com::geotab::ioxproto::Topic value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.TopicInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TopicInfo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TopicInfo& from_msg);
    int topic_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class Subscribe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.Subscribe) */ {
 public:
  inline Subscribe() : Subscribe(nullptr) {}
  ~Subscribe() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Subscribe(
      ::google::protobuf::internal::ConstantInitialized);

  inline Subscribe(const Subscribe& from) : Subscribe(nullptr, from) {}
  inline Subscribe(Subscribe&& from) noexcept
      : Subscribe(nullptr, std::move(from)) {}
  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscribe& operator=(Subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscribe* internal_default_instance() {
    return reinterpret_cast<const Subscribe*>(
        &_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Subscribe& a, Subscribe& b) { a.Swap(&b); }
  inline void Swap(Subscribe* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscribe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscribe* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Subscribe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Subscribe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Subscribe& from) { Subscribe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Subscribe* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.Subscribe"; }

 protected:
  explicit Subscribe(::google::protobuf::Arena* arena);
  Subscribe(::google::protobuf::Arena* arena, const Subscribe& from);
  Subscribe(::google::protobuf::Arena* arena, Subscribe&& from) noexcept
      : Subscribe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicFieldNumber = 1,
  };
  // .com.geotab.ioxproto.Topic topic = 1;
  void clear_topic() ;
  ::com::geotab::ioxproto::Topic topic() const;
  void set_topic(::com::geotab::ioxproto::Topic value);

  private:
  ::com::geotab::ioxproto::Topic _internal_topic() const;
  void _internal_set_topic(::com::geotab::ioxproto::Topic value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.Subscribe)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Subscribe_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Subscribe& from_msg);
    int topic_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class SubAck final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.SubAck) */ {
 public:
  inline SubAck() : SubAck(nullptr) {}
  ~SubAck() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubAck(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubAck(const SubAck& from) : SubAck(nullptr, from) {}
  inline SubAck(SubAck&& from) noexcept
      : SubAck(nullptr, std::move(from)) {}
  inline SubAck& operator=(const SubAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubAck& operator=(SubAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubAck* internal_default_instance() {
    return reinterpret_cast<const SubAck*>(
        &_SubAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SubAck& a, SubAck& b) { a.Swap(&b); }
  inline void Swap(SubAck* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SubAck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubAck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubAck& from) { SubAck::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SubAck* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.SubAck"; }

 protected:
  explicit SubAck(::google::protobuf::Arena* arena);
  SubAck(::google::protobuf::Arena* arena, const SubAck& from);
  SubAck(::google::protobuf::Arena* arena, SubAck&& from) noexcept
      : SubAck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Result = SubAck_Result;
  static constexpr Result SUB_ACK_RESULT_UNSPECIFIED = SubAck_Result_SUB_ACK_RESULT_UNSPECIFIED;
  static constexpr Result SUB_ACK_RESULT_SUCCESS = SubAck_Result_SUB_ACK_RESULT_SUCCESS;
  static constexpr Result SUB_ACK_RESULT_FAILED = SubAck_Result_SUB_ACK_RESULT_FAILED;
  static constexpr Result SUB_ACK_RESULT_UNKNOWN_TOPIC = SubAck_Result_SUB_ACK_RESULT_UNKNOWN_TOPIC;
  static constexpr Result SUB_ACK_RESULT_TOPIC_ALREADY_SUBBED = SubAck_Result_SUB_ACK_RESULT_TOPIC_ALREADY_SUBBED;
  static constexpr Result SUB_ACK_RESULT_TOPIC_NOT_SUBBED = SubAck_Result_SUB_ACK_RESULT_TOPIC_NOT_SUBBED;
  static constexpr Result SUB_ACK_RESULT_UNAVAILABLE = SubAck_Result_SUB_ACK_RESULT_UNAVAILABLE;
  static constexpr Result SUB_ACK_RESULT_DISABLED = SubAck_Result_SUB_ACK_RESULT_DISABLED;
  static inline bool Result_IsValid(int value) {
    return SubAck_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = SubAck_Result_Result_MIN;
  static constexpr Result Result_MAX = SubAck_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = SubAck_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Result_descriptor() {
    return SubAck_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return SubAck_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return SubAck_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
    kTopicFieldNumber = 2,
  };
  // .com.geotab.ioxproto.SubAck.Result result = 1;
  void clear_result() ;
  ::com::geotab::ioxproto::SubAck_Result result() const;
  void set_result(::com::geotab::ioxproto::SubAck_Result value);

  private:
  ::com::geotab::ioxproto::SubAck_Result _internal_result() const;
  void _internal_set_result(::com::geotab::ioxproto::SubAck_Result value);

  public:
  // .com.geotab.ioxproto.Topic topic = 2;
  void clear_topic() ;
  ::com::geotab::ioxproto::Topic topic() const;
  void set_topic(::com::geotab::ioxproto::Topic value);

  private:
  ::com::geotab::ioxproto::Topic _internal_topic() const;
  void _internal_set_topic(::com::geotab::ioxproto::Topic value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.SubAck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SubAck_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubAck& from_msg);
    int result_;
    int topic_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class ClearSubsAck final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.ClearSubsAck) */ {
 public:
  inline ClearSubsAck() : ClearSubsAck(nullptr) {}
  ~ClearSubsAck() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearSubsAck(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClearSubsAck(const ClearSubsAck& from) : ClearSubsAck(nullptr, from) {}
  inline ClearSubsAck(ClearSubsAck&& from) noexcept
      : ClearSubsAck(nullptr, std::move(from)) {}
  inline ClearSubsAck& operator=(const ClearSubsAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearSubsAck& operator=(ClearSubsAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearSubsAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearSubsAck* internal_default_instance() {
    return reinterpret_cast<const ClearSubsAck*>(
        &_ClearSubsAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ClearSubsAck& a, ClearSubsAck& b) { a.Swap(&b); }
  inline void Swap(ClearSubsAck* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearSubsAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearSubsAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ClearSubsAck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClearSubsAck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClearSubsAck& from) { ClearSubsAck::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClearSubsAck* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.ClearSubsAck"; }

 protected:
  explicit ClearSubsAck(::google::protobuf::Arena* arena);
  ClearSubsAck(::google::protobuf::Arena* arena, const ClearSubsAck& from);
  ClearSubsAck(::google::protobuf::Arena* arena, ClearSubsAck&& from) noexcept
      : ClearSubsAck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Result = ClearSubsAck_Result;
  static constexpr Result CLEAR_SUBS_ACK_RESULT_UNSPECIFIED = ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_UNSPECIFIED;
  static constexpr Result CLEAR_SUBS_ACK_RESULT_SUCCESS = ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_SUCCESS;
  static constexpr Result CLEAR_SUBS_ACK_RESULT_UNAVAILABLE = ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_UNAVAILABLE;
  static constexpr Result CLEAR_SUBS_ACK_RESULT_DISABLED = ClearSubsAck_Result_CLEAR_SUBS_ACK_RESULT_DISABLED;
  static inline bool Result_IsValid(int value) {
    return ClearSubsAck_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = ClearSubsAck_Result_Result_MIN;
  static constexpr Result Result_MAX = ClearSubsAck_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = ClearSubsAck_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Result_descriptor() {
    return ClearSubsAck_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return ClearSubsAck_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return ClearSubsAck_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kResultFieldNumber = 1,
  };
  // .com.geotab.ioxproto.ClearSubsAck.Result result = 1;
  void clear_result() ;
  ::com::geotab::ioxproto::ClearSubsAck_Result result() const;
  void set_result(::com::geotab::ioxproto::ClearSubsAck_Result value);

  private:
  ::com::geotab::ioxproto::ClearSubsAck_Result _internal_result() const;
  void _internal_set_result(::com::geotab::ioxproto::ClearSubsAck_Result value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.ClearSubsAck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ClearSubsAck_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClearSubsAck& from_msg);
    int result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class TopicInfoList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.TopicInfoList) */ {
 public:
  inline TopicInfoList() : TopicInfoList(nullptr) {}
  ~TopicInfoList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TopicInfoList(
      ::google::protobuf::internal::ConstantInitialized);

  inline TopicInfoList(const TopicInfoList& from) : TopicInfoList(nullptr, from) {}
  inline TopicInfoList(TopicInfoList&& from) noexcept
      : TopicInfoList(nullptr, std::move(from)) {}
  inline TopicInfoList& operator=(const TopicInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicInfoList& operator=(TopicInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicInfoList* internal_default_instance() {
    return reinterpret_cast<const TopicInfoList*>(
        &_TopicInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TopicInfoList& a, TopicInfoList& b) { a.Swap(&b); }
  inline void Swap(TopicInfoList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicInfoList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicInfoList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TopicInfoList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopicInfoList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TopicInfoList& from) { TopicInfoList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopicInfoList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.TopicInfoList"; }

 protected:
  explicit TopicInfoList(::google::protobuf::Arena* arena);
  TopicInfoList(::google::protobuf::Arena* arena, const TopicInfoList& from);
  TopicInfoList(::google::protobuf::Arena* arena, TopicInfoList&& from) noexcept
      : TopicInfoList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTopicsFieldNumber = 1,
  };
  // repeated .com.geotab.ioxproto.TopicInfo topics = 1;
  int topics_size() const;
  private:
  int _internal_topics_size() const;

  public:
  void clear_topics() ;
  ::com::geotab::ioxproto::TopicInfo* mutable_topics(int index);
  ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>* mutable_topics();

  private:
  const ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>& _internal_topics() const;
  ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>* _internal_mutable_topics();
  public:
  const ::com::geotab::ioxproto::TopicInfo& topics(int index) const;
  ::com::geotab::ioxproto::TopicInfo* add_topics();
  const ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>& topics() const;
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.TopicInfoList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TopicInfoList_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TopicInfoList& from_msg);
    ::google::protobuf::RepeatedPtrField< ::com::geotab::ioxproto::TopicInfo > topics_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class PubSubToGo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.PubSubToGo) */ {
 public:
  inline PubSubToGo() : PubSubToGo(nullptr) {}
  ~PubSubToGo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PubSubToGo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PubSubToGo(const PubSubToGo& from) : PubSubToGo(nullptr, from) {}
  inline PubSubToGo(PubSubToGo&& from) noexcept
      : PubSubToGo(nullptr, std::move(from)) {}
  inline PubSubToGo& operator=(const PubSubToGo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubSubToGo& operator=(PubSubToGo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubSubToGo& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kSub = 1,
    kUnsub = 2,
    kListSubs = 3,
    kClearSubs = 4,
    kListAvailTopics = 5,
    MSG_NOT_SET = 0,
  };
  static inline const PubSubToGo* internal_default_instance() {
    return reinterpret_cast<const PubSubToGo*>(
        &_PubSubToGo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(PubSubToGo& a, PubSubToGo& b) { a.Swap(&b); }
  inline void Swap(PubSubToGo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubSubToGo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubSubToGo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PubSubToGo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PubSubToGo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PubSubToGo& from) { PubSubToGo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PubSubToGo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.PubSubToGo"; }

 protected:
  explicit PubSubToGo(::google::protobuf::Arena* arena);
  PubSubToGo(::google::protobuf::Arena* arena, const PubSubToGo& from);
  PubSubToGo(::google::protobuf::Arena* arena, PubSubToGo&& from) noexcept
      : PubSubToGo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubFieldNumber = 1,
    kUnsubFieldNumber = 2,
    kListSubsFieldNumber = 3,
    kClearSubsFieldNumber = 4,
    kListAvailTopicsFieldNumber = 5,
  };
  // .com.geotab.ioxproto.Subscribe sub = 1;
  bool has_sub() const;
  private:
  bool _internal_has_sub() const;

  public:
  void clear_sub() ;
  const ::com::geotab::ioxproto::Subscribe& sub() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::Subscribe* release_sub();
  ::com::geotab::ioxproto::Subscribe* mutable_sub();
  void set_allocated_sub(::com::geotab::ioxproto::Subscribe* value);
  void unsafe_arena_set_allocated_sub(::com::geotab::ioxproto::Subscribe* value);
  ::com::geotab::ioxproto::Subscribe* unsafe_arena_release_sub();

  private:
  const ::com::geotab::ioxproto::Subscribe& _internal_sub() const;
  ::com::geotab::ioxproto::Subscribe* _internal_mutable_sub();

  public:
  // .com.geotab.ioxproto.Unsubscribe unsub = 2;
  bool has_unsub() const;
  private:
  bool _internal_has_unsub() const;

  public:
  void clear_unsub() ;
  const ::com::geotab::ioxproto::Unsubscribe& unsub() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::Unsubscribe* release_unsub();
  ::com::geotab::ioxproto::Unsubscribe* mutable_unsub();
  void set_allocated_unsub(::com::geotab::ioxproto::Unsubscribe* value);
  void unsafe_arena_set_allocated_unsub(::com::geotab::ioxproto::Unsubscribe* value);
  ::com::geotab::ioxproto::Unsubscribe* unsafe_arena_release_unsub();

  private:
  const ::com::geotab::ioxproto::Unsubscribe& _internal_unsub() const;
  ::com::geotab::ioxproto::Unsubscribe* _internal_mutable_unsub();

  public:
  // .google.protobuf.Empty list_subs = 3;
  bool has_list_subs() const;
  private:
  bool _internal_has_list_subs() const;

  public:
  void clear_list_subs() ;
  const ::google::protobuf::Empty& list_subs() const;
  PROTOBUF_NODISCARD ::google::protobuf::Empty* release_list_subs();
  ::google::protobuf::Empty* mutable_list_subs();
  void set_allocated_list_subs(::google::protobuf::Empty* value);
  void unsafe_arena_set_allocated_list_subs(::google::protobuf::Empty* value);
  ::google::protobuf::Empty* unsafe_arena_release_list_subs();

  private:
  const ::google::protobuf::Empty& _internal_list_subs() const;
  ::google::protobuf::Empty* _internal_mutable_list_subs();

  public:
  // .google.protobuf.Empty clear_subs = 4;
  bool has_clear_subs() const;
  private:
  bool _internal_has_clear_subs() const;

  public:
  void clear_clear_subs() ;
  const ::google::protobuf::Empty& clear_subs() const;
  PROTOBUF_NODISCARD ::google::protobuf::Empty* release_clear_subs();
  ::google::protobuf::Empty* mutable_clear_subs();
  void set_allocated_clear_subs(::google::protobuf::Empty* value);
  void unsafe_arena_set_allocated_clear_subs(::google::protobuf::Empty* value);
  ::google::protobuf::Empty* unsafe_arena_release_clear_subs();

  private:
  const ::google::protobuf::Empty& _internal_clear_subs() const;
  ::google::protobuf::Empty* _internal_mutable_clear_subs();

  public:
  // .google.protobuf.Empty list_avail_topics = 5;
  bool has_list_avail_topics() const;
  private:
  bool _internal_has_list_avail_topics() const;

  public:
  void clear_list_avail_topics() ;
  const ::google::protobuf::Empty& list_avail_topics() const;
  PROTOBUF_NODISCARD ::google::protobuf::Empty* release_list_avail_topics();
  ::google::protobuf::Empty* mutable_list_avail_topics();
  void set_allocated_list_avail_topics(::google::protobuf::Empty* value);
  void unsafe_arena_set_allocated_list_avail_topics(::google::protobuf::Empty* value);
  ::google::protobuf::Empty* unsafe_arena_release_list_avail_topics();

  private:
  const ::google::protobuf::Empty& _internal_list_avail_topics() const;
  ::google::protobuf::Empty* _internal_mutable_list_avail_topics();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.PubSubToGo)
 private:
  class _Internal;
  void set_has_sub();
  void set_has_unsub();
  void set_has_list_subs();
  void set_has_clear_subs();
  void set_has_list_avail_topics();
  inline bool has_msg() const;
  inline void clear_has_msg();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PubSubToGo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PubSubToGo& from_msg);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::geotab::ioxproto::Subscribe* sub_;
      ::com::geotab::ioxproto::Unsubscribe* unsub_;
      ::google::protobuf::Empty* list_subs_;
      ::google::protobuf::Empty* clear_subs_;
      ::google::protobuf::Empty* list_avail_topics_;
    } msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class Gps final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.Gps) */ {
 public:
  inline Gps() : Gps(nullptr) {}
  ~Gps() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Gps(
      ::google::protobuf::internal::ConstantInitialized);

  inline Gps(const Gps& from) : Gps(nullptr, from) {}
  inline Gps(Gps&& from) noexcept
      : Gps(nullptr, std::move(from)) {}
  inline Gps& operator=(const Gps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gps& operator=(Gps&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gps* internal_default_instance() {
    return reinterpret_cast<const Gps*>(
        &_Gps_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Gps& a, Gps& b) { a.Swap(&b); }
  inline void Swap(Gps* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Gps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Gps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Gps& from) { Gps::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Gps* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.Gps"; }

 protected:
  explicit Gps(::google::protobuf::Arena* arena);
  Gps(::google::protobuf::Arena* arena, const Gps& from);
  Gps(::google::protobuf::Arena* arena, Gps&& from) noexcept
      : Gps(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGpsTimeFieldNumber = 5,
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kHeadingFieldNumber = 4,
  };
  // .google.protobuf.Timestamp gps_time = 5;
  bool has_gps_time() const;
  void clear_gps_time() ;
  const ::google::protobuf::Timestamp& gps_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_gps_time();
  ::google::protobuf::Timestamp* mutable_gps_time();
  void set_allocated_gps_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_gps_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_gps_time();

  private:
  const ::google::protobuf::Timestamp& _internal_gps_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_gps_time();

  public:
  // float latitude = 1;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // float longitude = 2;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // float speed = 3;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // float heading = 4;
  void clear_heading() ;
  float heading() const;
  void set_heading(float value);

  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);

  public:
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.Gps)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Gps_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Gps& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* gps_time_;
    float latitude_;
    float longitude_;
    float speed_;
    float heading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class Publish final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.Publish) */ {
 public:
  inline Publish() : Publish(nullptr) {}
  ~Publish() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Publish(
      ::google::protobuf::internal::ConstantInitialized);

  inline Publish(const Publish& from) : Publish(nullptr, from) {}
  inline Publish(Publish&& from) noexcept
      : Publish(nullptr, std::move(from)) {}
  inline Publish& operator=(const Publish& from) {
    CopyFrom(from);
    return *this;
  }
  inline Publish& operator=(Publish&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Publish& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kBoolValue = 3,
    kIntValue = 4,
    kUintValue = 5,
    kFloatValue = 6,
    kStringValue = 7,
    kVec3Value = 8,
    kGpsValue = 9,
    VALUE_NOT_SET = 0,
  };
  static inline const Publish* internal_default_instance() {
    return reinterpret_cast<const Publish*>(
        &_Publish_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Publish& a, Publish& b) { a.Swap(&b); }
  inline void Swap(Publish* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Publish* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Publish* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Publish>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Publish& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Publish& from) { Publish::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Publish* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.Publish"; }

 protected:
  explicit Publish(::google::protobuf::Arena* arena);
  Publish(::google::protobuf::Arena* arena, const Publish& from);
  Publish(::google::protobuf::Arena* arena, Publish&& from) noexcept
      : Publish(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 1,
    kTopicFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kUintValueFieldNumber = 5,
    kFloatValueFieldNumber = 6,
    kStringValueFieldNumber = 7,
    kVec3ValueFieldNumber = 8,
    kGpsValueFieldNumber = 9,
  };
  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .com.geotab.ioxproto.Topic topic = 2;
  void clear_topic() ;
  ::com::geotab::ioxproto::Topic topic() const;
  void set_topic(::com::geotab::ioxproto::Topic value);

  private:
  ::com::geotab::ioxproto::Topic _internal_topic() const;
  void _internal_set_topic(::com::geotab::ioxproto::Topic value);

  public:
  // bool bool_value = 3;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // int32 int_value = 4;
  bool has_int_value() const;
  void clear_int_value() ;
  ::int32_t int_value() const;
  void set_int_value(::int32_t value);

  private:
  ::int32_t _internal_int_value() const;
  void _internal_set_int_value(::int32_t value);

  public:
  // uint32 uint_value = 5;
  bool has_uint_value() const;
  void clear_uint_value() ;
  ::uint32_t uint_value() const;
  void set_uint_value(::uint32_t value);

  private:
  ::uint32_t _internal_uint_value() const;
  void _internal_set_uint_value(::uint32_t value);

  public:
  // float float_value = 6;
  bool has_float_value() const;
  void clear_float_value() ;
  float float_value() const;
  void set_float_value(float value);

  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);

  public:
  // string string_value = 7;
  bool has_string_value() const;
  void clear_string_value() ;
  const std::string& string_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* value);

  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
      const std::string& value);
  std::string* _internal_mutable_string_value();

  public:
  // .com.geotab.ioxproto.Vec3 vec3_value = 8;
  bool has_vec3_value() const;
  private:
  bool _internal_has_vec3_value() const;

  public:
  void clear_vec3_value() ;
  const ::com::geotab::ioxproto::Vec3& vec3_value() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::Vec3* release_vec3_value();
  ::com::geotab::ioxproto::Vec3* mutable_vec3_value();
  void set_allocated_vec3_value(::com::geotab::ioxproto::Vec3* value);
  void unsafe_arena_set_allocated_vec3_value(::com::geotab::ioxproto::Vec3* value);
  ::com::geotab::ioxproto::Vec3* unsafe_arena_release_vec3_value();

  private:
  const ::com::geotab::ioxproto::Vec3& _internal_vec3_value() const;
  ::com::geotab::ioxproto::Vec3* _internal_mutable_vec3_value();

  public:
  // .com.geotab.ioxproto.Gps gps_value = 9;
  bool has_gps_value() const;
  private:
  bool _internal_has_gps_value() const;

  public:
  void clear_gps_value() ;
  const ::com::geotab::ioxproto::Gps& gps_value() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::Gps* release_gps_value();
  ::com::geotab::ioxproto::Gps* mutable_gps_value();
  void set_allocated_gps_value(::com::geotab::ioxproto::Gps* value);
  void unsafe_arena_set_allocated_gps_value(::com::geotab::ioxproto::Gps* value);
  ::com::geotab::ioxproto::Gps* unsafe_arena_release_gps_value();

  private:
  const ::com::geotab::ioxproto::Gps& _internal_gps_value() const;
  ::com::geotab::ioxproto::Gps* _internal_mutable_gps_value();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.Publish)
 private:
  class _Internal;
  void set_has_bool_value();
  void set_has_int_value();
  void set_has_uint_value();
  void set_has_float_value();
  void set_has_string_value();
  void set_has_vec3_value();
  void set_has_gps_value();
  inline bool has_value() const;
  inline void clear_has_value();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 9, 3,
      56, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Publish_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Publish& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* time_;
    int topic_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool bool_value_;
      ::int32_t int_value_;
      ::uint32_t uint_value_;
      float float_value_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
      ::com::geotab::ioxproto::Vec3* vec3_value_;
      ::com::geotab::ioxproto::Gps* gps_value_;
    } value_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class IoxToGo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.IoxToGo) */ {
 public:
  inline IoxToGo() : IoxToGo(nullptr) {}
  ~IoxToGo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IoxToGo(
      ::google::protobuf::internal::ConstantInitialized);

  inline IoxToGo(const IoxToGo& from) : IoxToGo(nullptr, from) {}
  inline IoxToGo(IoxToGo&& from) noexcept
      : IoxToGo(nullptr, std::move(from)) {}
  inline IoxToGo& operator=(const IoxToGo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IoxToGo& operator=(IoxToGo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IoxToGo& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kPubSub = 1,
    MSG_NOT_SET = 0,
  };
  static inline const IoxToGo* internal_default_instance() {
    return reinterpret_cast<const IoxToGo*>(
        &_IoxToGo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(IoxToGo& a, IoxToGo& b) { a.Swap(&b); }
  inline void Swap(IoxToGo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IoxToGo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IoxToGo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IoxToGo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IoxToGo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IoxToGo& from) { IoxToGo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IoxToGo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.IoxToGo"; }

 protected:
  explicit IoxToGo(::google::protobuf::Arena* arena);
  IoxToGo(::google::protobuf::Arena* arena, const IoxToGo& from);
  IoxToGo(::google::protobuf::Arena* arena, IoxToGo&& from) noexcept
      : IoxToGo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPubSubFieldNumber = 1,
  };
  // .com.geotab.ioxproto.PubSubToGo pub_sub = 1;
  bool has_pub_sub() const;
  private:
  bool _internal_has_pub_sub() const;

  public:
  void clear_pub_sub() ;
  const ::com::geotab::ioxproto::PubSubToGo& pub_sub() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::PubSubToGo* release_pub_sub();
  ::com::geotab::ioxproto::PubSubToGo* mutable_pub_sub();
  void set_allocated_pub_sub(::com::geotab::ioxproto::PubSubToGo* value);
  void unsafe_arena_set_allocated_pub_sub(::com::geotab::ioxproto::PubSubToGo* value);
  ::com::geotab::ioxproto::PubSubToGo* unsafe_arena_release_pub_sub();

  private:
  const ::com::geotab::ioxproto::PubSubToGo& _internal_pub_sub() const;
  ::com::geotab::ioxproto::PubSubToGo* _internal_mutable_pub_sub();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.IoxToGo)
 private:
  class _Internal;
  void set_has_pub_sub();
  inline bool has_msg() const;
  inline void clear_has_msg();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IoxToGo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IoxToGo& from_msg);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::geotab::ioxproto::PubSubToGo* pub_sub_;
    } msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class PubSubFromGo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.PubSubFromGo) */ {
 public:
  inline PubSubFromGo() : PubSubFromGo(nullptr) {}
  ~PubSubFromGo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PubSubFromGo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PubSubFromGo(const PubSubFromGo& from) : PubSubFromGo(nullptr, from) {}
  inline PubSubFromGo(PubSubFromGo&& from) noexcept
      : PubSubFromGo(nullptr, std::move(from)) {}
  inline PubSubFromGo& operator=(const PubSubFromGo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubSubFromGo& operator=(PubSubFromGo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubSubFromGo& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kSubAck = 1,
    kTopicList = 2,
    kTopicInfoList = 3,
    kPub = 4,
    kClearSubsAck = 5,
    MSG_NOT_SET = 0,
  };
  static inline const PubSubFromGo* internal_default_instance() {
    return reinterpret_cast<const PubSubFromGo*>(
        &_PubSubFromGo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PubSubFromGo& a, PubSubFromGo& b) { a.Swap(&b); }
  inline void Swap(PubSubFromGo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubSubFromGo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubSubFromGo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PubSubFromGo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PubSubFromGo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PubSubFromGo& from) { PubSubFromGo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PubSubFromGo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.PubSubFromGo"; }

 protected:
  explicit PubSubFromGo(::google::protobuf::Arena* arena);
  PubSubFromGo(::google::protobuf::Arena* arena, const PubSubFromGo& from);
  PubSubFromGo(::google::protobuf::Arena* arena, PubSubFromGo&& from) noexcept
      : PubSubFromGo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSubAckFieldNumber = 1,
    kTopicListFieldNumber = 2,
    kTopicInfoListFieldNumber = 3,
    kPubFieldNumber = 4,
    kClearSubsAckFieldNumber = 5,
  };
  // .com.geotab.ioxproto.SubAck sub_ack = 1;
  bool has_sub_ack() const;
  private:
  bool _internal_has_sub_ack() const;

  public:
  void clear_sub_ack() ;
  const ::com::geotab::ioxproto::SubAck& sub_ack() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::SubAck* release_sub_ack();
  ::com::geotab::ioxproto::SubAck* mutable_sub_ack();
  void set_allocated_sub_ack(::com::geotab::ioxproto::SubAck* value);
  void unsafe_arena_set_allocated_sub_ack(::com::geotab::ioxproto::SubAck* value);
  ::com::geotab::ioxproto::SubAck* unsafe_arena_release_sub_ack();

  private:
  const ::com::geotab::ioxproto::SubAck& _internal_sub_ack() const;
  ::com::geotab::ioxproto::SubAck* _internal_mutable_sub_ack();

  public:
  // .com.geotab.ioxproto.TopicList topic_list = 2;
  bool has_topic_list() const;
  private:
  bool _internal_has_topic_list() const;

  public:
  void clear_topic_list() ;
  const ::com::geotab::ioxproto::TopicList& topic_list() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::TopicList* release_topic_list();
  ::com::geotab::ioxproto::TopicList* mutable_topic_list();
  void set_allocated_topic_list(::com::geotab::ioxproto::TopicList* value);
  void unsafe_arena_set_allocated_topic_list(::com::geotab::ioxproto::TopicList* value);
  ::com::geotab::ioxproto::TopicList* unsafe_arena_release_topic_list();

  private:
  const ::com::geotab::ioxproto::TopicList& _internal_topic_list() const;
  ::com::geotab::ioxproto::TopicList* _internal_mutable_topic_list();

  public:
  // .com.geotab.ioxproto.TopicInfoList topic_info_list = 3;
  bool has_topic_info_list() const;
  private:
  bool _internal_has_topic_info_list() const;

  public:
  void clear_topic_info_list() ;
  const ::com::geotab::ioxproto::TopicInfoList& topic_info_list() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::TopicInfoList* release_topic_info_list();
  ::com::geotab::ioxproto::TopicInfoList* mutable_topic_info_list();
  void set_allocated_topic_info_list(::com::geotab::ioxproto::TopicInfoList* value);
  void unsafe_arena_set_allocated_topic_info_list(::com::geotab::ioxproto::TopicInfoList* value);
  ::com::geotab::ioxproto::TopicInfoList* unsafe_arena_release_topic_info_list();

  private:
  const ::com::geotab::ioxproto::TopicInfoList& _internal_topic_info_list() const;
  ::com::geotab::ioxproto::TopicInfoList* _internal_mutable_topic_info_list();

  public:
  // .com.geotab.ioxproto.Publish pub = 4;
  bool has_pub() const;
  private:
  bool _internal_has_pub() const;

  public:
  void clear_pub() ;
  const ::com::geotab::ioxproto::Publish& pub() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::Publish* release_pub();
  ::com::geotab::ioxproto::Publish* mutable_pub();
  void set_allocated_pub(::com::geotab::ioxproto::Publish* value);
  void unsafe_arena_set_allocated_pub(::com::geotab::ioxproto::Publish* value);
  ::com::geotab::ioxproto::Publish* unsafe_arena_release_pub();

  private:
  const ::com::geotab::ioxproto::Publish& _internal_pub() const;
  ::com::geotab::ioxproto::Publish* _internal_mutable_pub();

  public:
  // .com.geotab.ioxproto.ClearSubsAck clear_subs_ack = 5;
  bool has_clear_subs_ack() const;
  private:
  bool _internal_has_clear_subs_ack() const;

  public:
  void clear_clear_subs_ack() ;
  const ::com::geotab::ioxproto::ClearSubsAck& clear_subs_ack() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::ClearSubsAck* release_clear_subs_ack();
  ::com::geotab::ioxproto::ClearSubsAck* mutable_clear_subs_ack();
  void set_allocated_clear_subs_ack(::com::geotab::ioxproto::ClearSubsAck* value);
  void unsafe_arena_set_allocated_clear_subs_ack(::com::geotab::ioxproto::ClearSubsAck* value);
  ::com::geotab::ioxproto::ClearSubsAck* unsafe_arena_release_clear_subs_ack();

  private:
  const ::com::geotab::ioxproto::ClearSubsAck& _internal_clear_subs_ack() const;
  ::com::geotab::ioxproto::ClearSubsAck* _internal_mutable_clear_subs_ack();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.PubSubFromGo)
 private:
  class _Internal;
  void set_has_sub_ack();
  void set_has_topic_list();
  void set_has_topic_info_list();
  void set_has_pub();
  void set_has_clear_subs_ack();
  inline bool has_msg() const;
  inline void clear_has_msg();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_PubSubFromGo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PubSubFromGo& from_msg);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::geotab::ioxproto::SubAck* sub_ack_;
      ::com::geotab::ioxproto::TopicList* topic_list_;
      ::com::geotab::ioxproto::TopicInfoList* topic_info_list_;
      ::com::geotab::ioxproto::Publish* pub_;
      ::com::geotab::ioxproto::ClearSubsAck* clear_subs_ack_;
    } msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};
// -------------------------------------------------------------------

class IoxFromGo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:com.geotab.ioxproto.IoxFromGo) */ {
 public:
  inline IoxFromGo() : IoxFromGo(nullptr) {}
  ~IoxFromGo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IoxFromGo(
      ::google::protobuf::internal::ConstantInitialized);

  inline IoxFromGo(const IoxFromGo& from) : IoxFromGo(nullptr, from) {}
  inline IoxFromGo(IoxFromGo&& from) noexcept
      : IoxFromGo(nullptr, std::move(from)) {}
  inline IoxFromGo& operator=(const IoxFromGo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IoxFromGo& operator=(IoxFromGo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IoxFromGo& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kPubSub = 1,
    MSG_NOT_SET = 0,
  };
  static inline const IoxFromGo* internal_default_instance() {
    return reinterpret_cast<const IoxFromGo*>(
        &_IoxFromGo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(IoxFromGo& a, IoxFromGo& b) { a.Swap(&b); }
  inline void Swap(IoxFromGo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IoxFromGo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IoxFromGo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<IoxFromGo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IoxFromGo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IoxFromGo& from) { IoxFromGo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IoxFromGo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "com.geotab.ioxproto.IoxFromGo"; }

 protected:
  explicit IoxFromGo(::google::protobuf::Arena* arena);
  IoxFromGo(::google::protobuf::Arena* arena, const IoxFromGo& from);
  IoxFromGo(::google::protobuf::Arena* arena, IoxFromGo&& from) noexcept
      : IoxFromGo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPubSubFieldNumber = 1,
  };
  // .com.geotab.ioxproto.PubSubFromGo pub_sub = 1;
  bool has_pub_sub() const;
  private:
  bool _internal_has_pub_sub() const;

  public:
  void clear_pub_sub() ;
  const ::com::geotab::ioxproto::PubSubFromGo& pub_sub() const;
  PROTOBUF_NODISCARD ::com::geotab::ioxproto::PubSubFromGo* release_pub_sub();
  ::com::geotab::ioxproto::PubSubFromGo* mutable_pub_sub();
  void set_allocated_pub_sub(::com::geotab::ioxproto::PubSubFromGo* value);
  void unsafe_arena_set_allocated_pub_sub(::com::geotab::ioxproto::PubSubFromGo* value);
  ::com::geotab::ioxproto::PubSubFromGo* unsafe_arena_release_pub_sub();

  private:
  const ::com::geotab::ioxproto::PubSubFromGo& _internal_pub_sub() const;
  ::com::geotab::ioxproto::PubSubFromGo* _internal_mutable_pub_sub();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:com.geotab.ioxproto.IoxFromGo)
 private:
  class _Internal;
  void set_has_pub_sub();
  inline bool has_msg() const;
  inline void clear_has_msg();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_IoxFromGo_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IoxFromGo& from_msg);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::com::geotab::ioxproto::PubSubFromGo* pub_sub_;
    } msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iox_5fmessaging_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SubAck

// .com.geotab.ioxproto.SubAck.Result result = 1;
inline void SubAck::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::com::geotab::ioxproto::SubAck_Result SubAck::result() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.SubAck.result)
  return _internal_result();
}
inline void SubAck::set_result(::com::geotab::ioxproto::SubAck_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.SubAck.result)
}
inline ::com::geotab::ioxproto::SubAck_Result SubAck::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::SubAck_Result>(_impl_.result_);
}
inline void SubAck::_internal_set_result(::com::geotab::ioxproto::SubAck_Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// .com.geotab.ioxproto.Topic topic = 2;
inline void SubAck::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = 0;
}
inline ::com::geotab::ioxproto::Topic SubAck::topic() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.SubAck.topic)
  return _internal_topic();
}
inline void SubAck::set_topic(::com::geotab::ioxproto::Topic value) {
  _internal_set_topic(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.SubAck.topic)
}
inline ::com::geotab::ioxproto::Topic SubAck::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::Topic>(_impl_.topic_);
}
inline void SubAck::_internal_set_topic(::com::geotab::ioxproto::Topic value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = value;
}

// -------------------------------------------------------------------

// TopicInfo

// .com.geotab.ioxproto.Topic topic = 1;
inline void TopicInfo::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = 0;
}
inline ::com::geotab::ioxproto::Topic TopicInfo::topic() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.TopicInfo.topic)
  return _internal_topic();
}
inline void TopicInfo::set_topic(::com::geotab::ioxproto::Topic value) {
  _internal_set_topic(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.TopicInfo.topic)
}
inline ::com::geotab::ioxproto::Topic TopicInfo::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::Topic>(_impl_.topic_);
}
inline void TopicInfo::_internal_set_topic(::com::geotab::ioxproto::Topic value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = value;
}

// -------------------------------------------------------------------

// TopicList

// repeated .com.geotab.ioxproto.Topic topics = 1;
inline int TopicList::_internal_topics_size() const {
  return _internal_topics().size();
}
inline int TopicList::topics_size() const {
  return _internal_topics_size();
}
inline void TopicList::clear_topics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topics_.Clear();
}
inline ::com::geotab::ioxproto::Topic TopicList::topics(int index) const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.TopicList.topics)
  return static_cast<::com::geotab::ioxproto::Topic>(_internal_topics().Get(index));
}
inline void TopicList::set_topics(int index, ::com::geotab::ioxproto::Topic value) {
  _internal_mutable_topics()->Set(index, value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.TopicList.topics)
}
inline void TopicList::add_topics(::com::geotab::ioxproto::Topic value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_topics()->Add(value);
  // @@protoc_insertion_point(field_add:com.geotab.ioxproto.TopicList.topics)
}
inline const ::google::protobuf::RepeatedField<int>& TopicList::topics() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.geotab.ioxproto.TopicList.topics)
  return _internal_topics();
}
inline ::google::protobuf::RepeatedField<int>* TopicList::mutable_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.geotab.ioxproto.TopicList.topics)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_topics();
}
inline const ::google::protobuf::RepeatedField<int>& TopicList::_internal_topics()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.topics_;
}
inline ::google::protobuf::RepeatedField<int>* TopicList::_internal_mutable_topics() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.topics_;
}

// -------------------------------------------------------------------

// TopicInfoList

// repeated .com.geotab.ioxproto.TopicInfo topics = 1;
inline int TopicInfoList::_internal_topics_size() const {
  return _internal_topics().size();
}
inline int TopicInfoList::topics_size() const {
  return _internal_topics_size();
}
inline void TopicInfoList::clear_topics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topics_.Clear();
}
inline ::com::geotab::ioxproto::TopicInfo* TopicInfoList::mutable_topics(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.TopicInfoList.topics)
  return _internal_mutable_topics()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>* TopicInfoList::mutable_topics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:com.geotab.ioxproto.TopicInfoList.topics)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_topics();
}
inline const ::com::geotab::ioxproto::TopicInfo& TopicInfoList::topics(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.TopicInfoList.topics)
  return _internal_topics().Get(index);
}
inline ::com::geotab::ioxproto::TopicInfo* TopicInfoList::add_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::com::geotab::ioxproto::TopicInfo* _add = _internal_mutable_topics()->Add();
  // @@protoc_insertion_point(field_add:com.geotab.ioxproto.TopicInfoList.topics)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>& TopicInfoList::topics() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:com.geotab.ioxproto.TopicInfoList.topics)
  return _internal_topics();
}
inline const ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>&
TopicInfoList::_internal_topics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.topics_;
}
inline ::google::protobuf::RepeatedPtrField<::com::geotab::ioxproto::TopicInfo>*
TopicInfoList::_internal_mutable_topics() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.topics_;
}

// -------------------------------------------------------------------

// ClearSubsAck

// .com.geotab.ioxproto.ClearSubsAck.Result result = 1;
inline void ClearSubsAck::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::com::geotab::ioxproto::ClearSubsAck_Result ClearSubsAck::result() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.ClearSubsAck.result)
  return _internal_result();
}
inline void ClearSubsAck::set_result(::com::geotab::ioxproto::ClearSubsAck_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.ClearSubsAck.result)
}
inline ::com::geotab::ioxproto::ClearSubsAck_Result ClearSubsAck::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::ClearSubsAck_Result>(_impl_.result_);
}
inline void ClearSubsAck::_internal_set_result(::com::geotab::ioxproto::ClearSubsAck_Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Vec3.x)
  return _internal_x();
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Vec3.x)
}
inline float Vec3::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void Vec3::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 2;
inline void Vec3::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Vec3.y)
  return _internal_y();
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Vec3.y)
}
inline float Vec3::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void Vec3::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 3;
inline void Vec3::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Vec3.z)
  return _internal_z();
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Vec3.z)
}
inline float Vec3::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void Vec3::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Gps

// float latitude = 1;
inline void Gps::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = 0;
}
inline float Gps::latitude() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Gps.latitude)
  return _internal_latitude();
}
inline void Gps::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Gps.latitude)
}
inline float Gps::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_;
}
inline void Gps::_internal_set_latitude(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = value;
}

// float longitude = 2;
inline void Gps::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = 0;
}
inline float Gps::longitude() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Gps.longitude)
  return _internal_longitude();
}
inline void Gps::set_longitude(float value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Gps.longitude)
}
inline float Gps::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_;
}
inline void Gps::_internal_set_longitude(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = value;
}

// float speed = 3;
inline void Gps::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
}
inline float Gps::speed() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Gps.speed)
  return _internal_speed();
}
inline void Gps::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Gps.speed)
}
inline float Gps::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void Gps::_internal_set_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// float heading = 4;
inline void Gps::clear_heading() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heading_ = 0;
}
inline float Gps::heading() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Gps.heading)
  return _internal_heading();
}
inline void Gps::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Gps.heading)
}
inline float Gps::_internal_heading() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.heading_;
}
inline void Gps::_internal_set_heading(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heading_ = value;
}

// .google.protobuf.Timestamp gps_time = 5;
inline bool Gps::has_gps_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gps_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Gps::_internal_gps_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.gps_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Gps::gps_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Gps.gps_time)
  return _internal_gps_time();
}
inline void Gps::unsafe_arena_set_allocated_gps_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gps_time_);
  }
  _impl_.gps_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.Gps.gps_time)
}
inline ::google::protobuf::Timestamp* Gps::release_gps_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.gps_time_;
  _impl_.gps_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Gps::unsafe_arena_release_gps_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.Gps.gps_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.gps_time_;
  _impl_.gps_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Gps::_internal_mutable_gps_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.gps_time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.gps_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.gps_time_;
}
inline ::google::protobuf::Timestamp* Gps::mutable_gps_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gps_time();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.Gps.gps_time)
  return _msg;
}
inline void Gps::set_allocated_gps_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.gps_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.gps_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.geotab.ioxproto.Gps.gps_time)
}

// -------------------------------------------------------------------

// Publish

// .google.protobuf.Timestamp time = 1;
inline bool Publish::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Publish::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Publish::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.time)
  return _internal_time();
}
inline void Publish::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.Publish.time)
}
inline ::google::protobuf::Timestamp* Publish::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Publish::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.Publish.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Publish::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* Publish::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.Publish.time)
  return _msg;
}
inline void Publish::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:com.geotab.ioxproto.Publish.time)
}

// .com.geotab.ioxproto.Topic topic = 2;
inline void Publish::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = 0;
}
inline ::com::geotab::ioxproto::Topic Publish::topic() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.topic)
  return _internal_topic();
}
inline void Publish::set_topic(::com::geotab::ioxproto::Topic value) {
  _internal_set_topic(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Publish.topic)
}
inline ::com::geotab::ioxproto::Topic Publish::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::Topic>(_impl_.topic_);
}
inline void Publish::_internal_set_topic(::com::geotab::ioxproto::Topic value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = value;
}

// bool bool_value = 3;
inline bool Publish::has_bool_value() const {
  return value_case() == kBoolValue;
}
inline void Publish::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Publish::clear_bool_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kBoolValue) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Publish::bool_value() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.bool_value)
  return _internal_bool_value();
}
inline void Publish::set_bool_value(bool value) {
  if (value_case() != kBoolValue) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Publish.bool_value)
}
inline bool Publish::_internal_bool_value() const {
  if (value_case() == kBoolValue) {
    return _impl_.value_.bool_value_;
  }
  return false;
}

// int32 int_value = 4;
inline bool Publish::has_int_value() const {
  return value_case() == kIntValue;
}
inline void Publish::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void Publish::clear_int_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kIntValue) {
    _impl_.value_.int_value_ = 0;
    clear_has_value();
  }
}
inline ::int32_t Publish::int_value() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.int_value)
  return _internal_int_value();
}
inline void Publish::set_int_value(::int32_t value) {
  if (value_case() != kIntValue) {
    clear_value();
    set_has_int_value();
  }
  _impl_.value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Publish.int_value)
}
inline ::int32_t Publish::_internal_int_value() const {
  if (value_case() == kIntValue) {
    return _impl_.value_.int_value_;
  }
  return 0;
}

// uint32 uint_value = 5;
inline bool Publish::has_uint_value() const {
  return value_case() == kUintValue;
}
inline void Publish::set_has_uint_value() {
  _impl_._oneof_case_[0] = kUintValue;
}
inline void Publish::clear_uint_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kUintValue) {
    _impl_.value_.uint_value_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t Publish::uint_value() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.uint_value)
  return _internal_uint_value();
}
inline void Publish::set_uint_value(::uint32_t value) {
  if (value_case() != kUintValue) {
    clear_value();
    set_has_uint_value();
  }
  _impl_.value_.uint_value_ = value;
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Publish.uint_value)
}
inline ::uint32_t Publish::_internal_uint_value() const {
  if (value_case() == kUintValue) {
    return _impl_.value_.uint_value_;
  }
  return 0u;
}

// float float_value = 6;
inline bool Publish::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Publish::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void Publish::clear_float_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kFloatValue) {
    _impl_.value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float Publish::float_value() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.float_value)
  return _internal_float_value();
}
inline void Publish::set_float_value(float value) {
  if (value_case() != kFloatValue) {
    clear_value();
    set_has_float_value();
  }
  _impl_.value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Publish.float_value)
}
inline float Publish::_internal_float_value() const {
  if (value_case() == kFloatValue) {
    return _impl_.value_.float_value_;
  }
  return 0;
}

// string string_value = 7;
inline bool Publish::has_string_value() const {
  return value_case() == kStringValue;
}
inline void Publish::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void Publish::clear_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kStringValue) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Publish::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Publish::set_string_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Publish.string_value)
}
inline std::string* Publish::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.Publish.string_value)
  return _s;
}
inline const std::string& Publish::_internal_string_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (value_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.string_value_.Get();
}
inline void Publish::_internal_set_string_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArena());
}
inline std::string* Publish::_internal_mutable_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable( GetArena());
}
inline std::string* Publish::release_string_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.Publish.string_value)
  if (value_case() != kStringValue) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.string_value_.Release();
}
inline void Publish::set_allocated_string_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:com.geotab.ioxproto.Publish.string_value)
}

// .com.geotab.ioxproto.Vec3 vec3_value = 8;
inline bool Publish::has_vec3_value() const {
  return value_case() == kVec3Value;
}
inline bool Publish::_internal_has_vec3_value() const {
  return value_case() == kVec3Value;
}
inline void Publish::set_has_vec3_value() {
  _impl_._oneof_case_[0] = kVec3Value;
}
inline void Publish::clear_vec3_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kVec3Value) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.vec3_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.vec3_value_);
    }
    clear_has_value();
  }
}
inline ::com::geotab::ioxproto::Vec3* Publish::release_vec3_value() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.Publish.vec3_value)
  if (value_case() == kVec3Value) {
    clear_has_value();
    auto* temp = _impl_.value_.vec3_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.vec3_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::Vec3& Publish::_internal_vec3_value() const {
  return value_case() == kVec3Value ? *_impl_.value_.vec3_value_ : reinterpret_cast<::com::geotab::ioxproto::Vec3&>(::com::geotab::ioxproto::_Vec3_default_instance_);
}
inline const ::com::geotab::ioxproto::Vec3& Publish::vec3_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.vec3_value)
  return _internal_vec3_value();
}
inline ::com::geotab::ioxproto::Vec3* Publish::unsafe_arena_release_vec3_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.Publish.vec3_value)
  if (value_case() == kVec3Value) {
    clear_has_value();
    auto* temp = _impl_.value_.vec3_value_;
    _impl_.value_.vec3_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Publish::unsafe_arena_set_allocated_vec3_value(::com::geotab::ioxproto::Vec3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_vec3_value();
    _impl_.value_.vec3_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.Publish.vec3_value)
}
inline ::com::geotab::ioxproto::Vec3* Publish::_internal_mutable_vec3_value() {
  if (value_case() != kVec3Value) {
    clear_value();
    set_has_vec3_value();
    _impl_.value_.vec3_value_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::Vec3>(GetArena());
  }
  return _impl_.value_.vec3_value_;
}
inline ::com::geotab::ioxproto::Vec3* Publish::mutable_vec3_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::Vec3* _msg = _internal_mutable_vec3_value();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.Publish.vec3_value)
  return _msg;
}

// .com.geotab.ioxproto.Gps gps_value = 9;
inline bool Publish::has_gps_value() const {
  return value_case() == kGpsValue;
}
inline bool Publish::_internal_has_gps_value() const {
  return value_case() == kGpsValue;
}
inline void Publish::set_has_gps_value() {
  _impl_._oneof_case_[0] = kGpsValue;
}
inline void Publish::clear_gps_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_case() == kGpsValue) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.gps_value_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.value_.gps_value_);
    }
    clear_has_value();
  }
}
inline ::com::geotab::ioxproto::Gps* Publish::release_gps_value() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.Publish.gps_value)
  if (value_case() == kGpsValue) {
    clear_has_value();
    auto* temp = _impl_.value_.gps_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.gps_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::Gps& Publish::_internal_gps_value() const {
  return value_case() == kGpsValue ? *_impl_.value_.gps_value_ : reinterpret_cast<::com::geotab::ioxproto::Gps&>(::com::geotab::ioxproto::_Gps_default_instance_);
}
inline const ::com::geotab::ioxproto::Gps& Publish::gps_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Publish.gps_value)
  return _internal_gps_value();
}
inline ::com::geotab::ioxproto::Gps* Publish::unsafe_arena_release_gps_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.Publish.gps_value)
  if (value_case() == kGpsValue) {
    clear_has_value();
    auto* temp = _impl_.value_.gps_value_;
    _impl_.value_.gps_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Publish::unsafe_arena_set_allocated_gps_value(::com::geotab::ioxproto::Gps* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_gps_value();
    _impl_.value_.gps_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.Publish.gps_value)
}
inline ::com::geotab::ioxproto::Gps* Publish::_internal_mutable_gps_value() {
  if (value_case() != kGpsValue) {
    clear_value();
    set_has_gps_value();
    _impl_.value_.gps_value_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::Gps>(GetArena());
  }
  return _impl_.value_.gps_value_;
}
inline ::com::geotab::ioxproto::Gps* Publish::mutable_gps_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::Gps* _msg = _internal_mutable_gps_value();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.Publish.gps_value)
  return _msg;
}

inline bool Publish::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Publish::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Publish::ValueCase Publish::value_case() const {
  return Publish::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Subscribe

// .com.geotab.ioxproto.Topic topic = 1;
inline void Subscribe::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = 0;
}
inline ::com::geotab::ioxproto::Topic Subscribe::topic() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Subscribe.topic)
  return _internal_topic();
}
inline void Subscribe::set_topic(::com::geotab::ioxproto::Topic value) {
  _internal_set_topic(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Subscribe.topic)
}
inline ::com::geotab::ioxproto::Topic Subscribe::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::Topic>(_impl_.topic_);
}
inline void Subscribe::_internal_set_topic(::com::geotab::ioxproto::Topic value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = value;
}

// -------------------------------------------------------------------

// Unsubscribe

// .com.geotab.ioxproto.Topic topic = 1;
inline void Unsubscribe::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = 0;
}
inline ::com::geotab::ioxproto::Topic Unsubscribe::topic() const {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.Unsubscribe.topic)
  return _internal_topic();
}
inline void Unsubscribe::set_topic(::com::geotab::ioxproto::Topic value) {
  _internal_set_topic(value);
  // @@protoc_insertion_point(field_set:com.geotab.ioxproto.Unsubscribe.topic)
}
inline ::com::geotab::ioxproto::Topic Unsubscribe::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::com::geotab::ioxproto::Topic>(_impl_.topic_);
}
inline void Unsubscribe::_internal_set_topic(::com::geotab::ioxproto::Topic value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_ = value;
}

// -------------------------------------------------------------------

// PubSubToGo

// .com.geotab.ioxproto.Subscribe sub = 1;
inline bool PubSubToGo::has_sub() const {
  return msg_case() == kSub;
}
inline bool PubSubToGo::_internal_has_sub() const {
  return msg_case() == kSub;
}
inline void PubSubToGo::set_has_sub() {
  _impl_._oneof_case_[0] = kSub;
}
inline void PubSubToGo::clear_sub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kSub) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.sub_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.sub_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::Subscribe* PubSubToGo::release_sub() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubToGo.sub)
  if (msg_case() == kSub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sub_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::Subscribe& PubSubToGo::_internal_sub() const {
  return msg_case() == kSub ? *_impl_.msg_.sub_ : reinterpret_cast<::com::geotab::ioxproto::Subscribe&>(::com::geotab::ioxproto::_Subscribe_default_instance_);
}
inline const ::com::geotab::ioxproto::Subscribe& PubSubToGo::sub() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubToGo.sub)
  return _internal_sub();
}
inline ::com::geotab::ioxproto::Subscribe* PubSubToGo::unsafe_arena_release_sub() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubToGo.sub)
  if (msg_case() == kSub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sub_;
    _impl_.msg_.sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubToGo::unsafe_arena_set_allocated_sub(::com::geotab::ioxproto::Subscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_sub();
    _impl_.msg_.sub_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubToGo.sub)
}
inline ::com::geotab::ioxproto::Subscribe* PubSubToGo::_internal_mutable_sub() {
  if (msg_case() != kSub) {
    clear_msg();
    set_has_sub();
    _impl_.msg_.sub_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::Subscribe>(GetArena());
  }
  return _impl_.msg_.sub_;
}
inline ::com::geotab::ioxproto::Subscribe* PubSubToGo::mutable_sub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::Subscribe* _msg = _internal_mutable_sub();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubToGo.sub)
  return _msg;
}

// .com.geotab.ioxproto.Unsubscribe unsub = 2;
inline bool PubSubToGo::has_unsub() const {
  return msg_case() == kUnsub;
}
inline bool PubSubToGo::_internal_has_unsub() const {
  return msg_case() == kUnsub;
}
inline void PubSubToGo::set_has_unsub() {
  _impl_._oneof_case_[0] = kUnsub;
}
inline void PubSubToGo::clear_unsub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kUnsub) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.unsub_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.unsub_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::Unsubscribe* PubSubToGo::release_unsub() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubToGo.unsub)
  if (msg_case() == kUnsub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.unsub_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.unsub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::Unsubscribe& PubSubToGo::_internal_unsub() const {
  return msg_case() == kUnsub ? *_impl_.msg_.unsub_ : reinterpret_cast<::com::geotab::ioxproto::Unsubscribe&>(::com::geotab::ioxproto::_Unsubscribe_default_instance_);
}
inline const ::com::geotab::ioxproto::Unsubscribe& PubSubToGo::unsub() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubToGo.unsub)
  return _internal_unsub();
}
inline ::com::geotab::ioxproto::Unsubscribe* PubSubToGo::unsafe_arena_release_unsub() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubToGo.unsub)
  if (msg_case() == kUnsub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.unsub_;
    _impl_.msg_.unsub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubToGo::unsafe_arena_set_allocated_unsub(::com::geotab::ioxproto::Unsubscribe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_unsub();
    _impl_.msg_.unsub_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubToGo.unsub)
}
inline ::com::geotab::ioxproto::Unsubscribe* PubSubToGo::_internal_mutable_unsub() {
  if (msg_case() != kUnsub) {
    clear_msg();
    set_has_unsub();
    _impl_.msg_.unsub_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::Unsubscribe>(GetArena());
  }
  return _impl_.msg_.unsub_;
}
inline ::com::geotab::ioxproto::Unsubscribe* PubSubToGo::mutable_unsub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::Unsubscribe* _msg = _internal_mutable_unsub();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubToGo.unsub)
  return _msg;
}

// .google.protobuf.Empty list_subs = 3;
inline bool PubSubToGo::has_list_subs() const {
  return msg_case() == kListSubs;
}
inline bool PubSubToGo::_internal_has_list_subs() const {
  return msg_case() == kListSubs;
}
inline void PubSubToGo::set_has_list_subs() {
  _impl_._oneof_case_[0] = kListSubs;
}
inline ::google::protobuf::Empty* PubSubToGo::release_list_subs() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubToGo.list_subs)
  if (msg_case() == kListSubs) {
    clear_has_msg();
    auto* temp = _impl_.msg_.list_subs_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.list_subs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& PubSubToGo::_internal_list_subs() const {
  return msg_case() == kListSubs ? *_impl_.msg_.list_subs_ : reinterpret_cast<::google::protobuf::Empty&>(::google::protobuf::_Empty_default_instance_);
}
inline const ::google::protobuf::Empty& PubSubToGo::list_subs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubToGo.list_subs)
  return _internal_list_subs();
}
inline ::google::protobuf::Empty* PubSubToGo::unsafe_arena_release_list_subs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubToGo.list_subs)
  if (msg_case() == kListSubs) {
    clear_has_msg();
    auto* temp = _impl_.msg_.list_subs_;
    _impl_.msg_.list_subs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubToGo::unsafe_arena_set_allocated_list_subs(::google::protobuf::Empty* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_list_subs();
    _impl_.msg_.list_subs_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubToGo.list_subs)
}
inline ::google::protobuf::Empty* PubSubToGo::_internal_mutable_list_subs() {
  if (msg_case() != kListSubs) {
    clear_msg();
    set_has_list_subs();
    _impl_.msg_.list_subs_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Empty>(GetArena());
  }
  return _impl_.msg_.list_subs_;
}
inline ::google::protobuf::Empty* PubSubToGo::mutable_list_subs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Empty* _msg = _internal_mutable_list_subs();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubToGo.list_subs)
  return _msg;
}

// .google.protobuf.Empty clear_subs = 4;
inline bool PubSubToGo::has_clear_subs() const {
  return msg_case() == kClearSubs;
}
inline bool PubSubToGo::_internal_has_clear_subs() const {
  return msg_case() == kClearSubs;
}
inline void PubSubToGo::set_has_clear_subs() {
  _impl_._oneof_case_[0] = kClearSubs;
}
inline ::google::protobuf::Empty* PubSubToGo::release_clear_subs() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubToGo.clear_subs)
  if (msg_case() == kClearSubs) {
    clear_has_msg();
    auto* temp = _impl_.msg_.clear_subs_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.clear_subs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& PubSubToGo::_internal_clear_subs() const {
  return msg_case() == kClearSubs ? *_impl_.msg_.clear_subs_ : reinterpret_cast<::google::protobuf::Empty&>(::google::protobuf::_Empty_default_instance_);
}
inline const ::google::protobuf::Empty& PubSubToGo::clear_subs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubToGo.clear_subs)
  return _internal_clear_subs();
}
inline ::google::protobuf::Empty* PubSubToGo::unsafe_arena_release_clear_subs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubToGo.clear_subs)
  if (msg_case() == kClearSubs) {
    clear_has_msg();
    auto* temp = _impl_.msg_.clear_subs_;
    _impl_.msg_.clear_subs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubToGo::unsafe_arena_set_allocated_clear_subs(::google::protobuf::Empty* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_clear_subs();
    _impl_.msg_.clear_subs_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubToGo.clear_subs)
}
inline ::google::protobuf::Empty* PubSubToGo::_internal_mutable_clear_subs() {
  if (msg_case() != kClearSubs) {
    clear_msg();
    set_has_clear_subs();
    _impl_.msg_.clear_subs_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Empty>(GetArena());
  }
  return _impl_.msg_.clear_subs_;
}
inline ::google::protobuf::Empty* PubSubToGo::mutable_clear_subs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Empty* _msg = _internal_mutable_clear_subs();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubToGo.clear_subs)
  return _msg;
}

// .google.protobuf.Empty list_avail_topics = 5;
inline bool PubSubToGo::has_list_avail_topics() const {
  return msg_case() == kListAvailTopics;
}
inline bool PubSubToGo::_internal_has_list_avail_topics() const {
  return msg_case() == kListAvailTopics;
}
inline void PubSubToGo::set_has_list_avail_topics() {
  _impl_._oneof_case_[0] = kListAvailTopics;
}
inline ::google::protobuf::Empty* PubSubToGo::release_list_avail_topics() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubToGo.list_avail_topics)
  if (msg_case() == kListAvailTopics) {
    clear_has_msg();
    auto* temp = _impl_.msg_.list_avail_topics_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.list_avail_topics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& PubSubToGo::_internal_list_avail_topics() const {
  return msg_case() == kListAvailTopics ? *_impl_.msg_.list_avail_topics_ : reinterpret_cast<::google::protobuf::Empty&>(::google::protobuf::_Empty_default_instance_);
}
inline const ::google::protobuf::Empty& PubSubToGo::list_avail_topics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubToGo.list_avail_topics)
  return _internal_list_avail_topics();
}
inline ::google::protobuf::Empty* PubSubToGo::unsafe_arena_release_list_avail_topics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubToGo.list_avail_topics)
  if (msg_case() == kListAvailTopics) {
    clear_has_msg();
    auto* temp = _impl_.msg_.list_avail_topics_;
    _impl_.msg_.list_avail_topics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubToGo::unsafe_arena_set_allocated_list_avail_topics(::google::protobuf::Empty* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_list_avail_topics();
    _impl_.msg_.list_avail_topics_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubToGo.list_avail_topics)
}
inline ::google::protobuf::Empty* PubSubToGo::_internal_mutable_list_avail_topics() {
  if (msg_case() != kListAvailTopics) {
    clear_msg();
    set_has_list_avail_topics();
    _impl_.msg_.list_avail_topics_ =
        ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Empty>(GetArena());
  }
  return _impl_.msg_.list_avail_topics_;
}
inline ::google::protobuf::Empty* PubSubToGo::mutable_list_avail_topics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Empty* _msg = _internal_mutable_list_avail_topics();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubToGo.list_avail_topics)
  return _msg;
}

inline bool PubSubToGo::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void PubSubToGo::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline PubSubToGo::MsgCase PubSubToGo::msg_case() const {
  return PubSubToGo::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PubSubFromGo

// .com.geotab.ioxproto.SubAck sub_ack = 1;
inline bool PubSubFromGo::has_sub_ack() const {
  return msg_case() == kSubAck;
}
inline bool PubSubFromGo::_internal_has_sub_ack() const {
  return msg_case() == kSubAck;
}
inline void PubSubFromGo::set_has_sub_ack() {
  _impl_._oneof_case_[0] = kSubAck;
}
inline void PubSubFromGo::clear_sub_ack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kSubAck) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.sub_ack_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.sub_ack_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::SubAck* PubSubFromGo::release_sub_ack() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubFromGo.sub_ack)
  if (msg_case() == kSubAck) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sub_ack_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.sub_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::SubAck& PubSubFromGo::_internal_sub_ack() const {
  return msg_case() == kSubAck ? *_impl_.msg_.sub_ack_ : reinterpret_cast<::com::geotab::ioxproto::SubAck&>(::com::geotab::ioxproto::_SubAck_default_instance_);
}
inline const ::com::geotab::ioxproto::SubAck& PubSubFromGo::sub_ack() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubFromGo.sub_ack)
  return _internal_sub_ack();
}
inline ::com::geotab::ioxproto::SubAck* PubSubFromGo::unsafe_arena_release_sub_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubFromGo.sub_ack)
  if (msg_case() == kSubAck) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sub_ack_;
    _impl_.msg_.sub_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubFromGo::unsafe_arena_set_allocated_sub_ack(::com::geotab::ioxproto::SubAck* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_sub_ack();
    _impl_.msg_.sub_ack_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubFromGo.sub_ack)
}
inline ::com::geotab::ioxproto::SubAck* PubSubFromGo::_internal_mutable_sub_ack() {
  if (msg_case() != kSubAck) {
    clear_msg();
    set_has_sub_ack();
    _impl_.msg_.sub_ack_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::SubAck>(GetArena());
  }
  return _impl_.msg_.sub_ack_;
}
inline ::com::geotab::ioxproto::SubAck* PubSubFromGo::mutable_sub_ack() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::SubAck* _msg = _internal_mutable_sub_ack();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubFromGo.sub_ack)
  return _msg;
}

// .com.geotab.ioxproto.TopicList topic_list = 2;
inline bool PubSubFromGo::has_topic_list() const {
  return msg_case() == kTopicList;
}
inline bool PubSubFromGo::_internal_has_topic_list() const {
  return msg_case() == kTopicList;
}
inline void PubSubFromGo::set_has_topic_list() {
  _impl_._oneof_case_[0] = kTopicList;
}
inline void PubSubFromGo::clear_topic_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kTopicList) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.topic_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.topic_list_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::TopicList* PubSubFromGo::release_topic_list() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubFromGo.topic_list)
  if (msg_case() == kTopicList) {
    clear_has_msg();
    auto* temp = _impl_.msg_.topic_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.topic_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::TopicList& PubSubFromGo::_internal_topic_list() const {
  return msg_case() == kTopicList ? *_impl_.msg_.topic_list_ : reinterpret_cast<::com::geotab::ioxproto::TopicList&>(::com::geotab::ioxproto::_TopicList_default_instance_);
}
inline const ::com::geotab::ioxproto::TopicList& PubSubFromGo::topic_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubFromGo.topic_list)
  return _internal_topic_list();
}
inline ::com::geotab::ioxproto::TopicList* PubSubFromGo::unsafe_arena_release_topic_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubFromGo.topic_list)
  if (msg_case() == kTopicList) {
    clear_has_msg();
    auto* temp = _impl_.msg_.topic_list_;
    _impl_.msg_.topic_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubFromGo::unsafe_arena_set_allocated_topic_list(::com::geotab::ioxproto::TopicList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_topic_list();
    _impl_.msg_.topic_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubFromGo.topic_list)
}
inline ::com::geotab::ioxproto::TopicList* PubSubFromGo::_internal_mutable_topic_list() {
  if (msg_case() != kTopicList) {
    clear_msg();
    set_has_topic_list();
    _impl_.msg_.topic_list_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::TopicList>(GetArena());
  }
  return _impl_.msg_.topic_list_;
}
inline ::com::geotab::ioxproto::TopicList* PubSubFromGo::mutable_topic_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::TopicList* _msg = _internal_mutable_topic_list();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubFromGo.topic_list)
  return _msg;
}

// .com.geotab.ioxproto.TopicInfoList topic_info_list = 3;
inline bool PubSubFromGo::has_topic_info_list() const {
  return msg_case() == kTopicInfoList;
}
inline bool PubSubFromGo::_internal_has_topic_info_list() const {
  return msg_case() == kTopicInfoList;
}
inline void PubSubFromGo::set_has_topic_info_list() {
  _impl_._oneof_case_[0] = kTopicInfoList;
}
inline void PubSubFromGo::clear_topic_info_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kTopicInfoList) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.topic_info_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.topic_info_list_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::TopicInfoList* PubSubFromGo::release_topic_info_list() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubFromGo.topic_info_list)
  if (msg_case() == kTopicInfoList) {
    clear_has_msg();
    auto* temp = _impl_.msg_.topic_info_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.topic_info_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::TopicInfoList& PubSubFromGo::_internal_topic_info_list() const {
  return msg_case() == kTopicInfoList ? *_impl_.msg_.topic_info_list_ : reinterpret_cast<::com::geotab::ioxproto::TopicInfoList&>(::com::geotab::ioxproto::_TopicInfoList_default_instance_);
}
inline const ::com::geotab::ioxproto::TopicInfoList& PubSubFromGo::topic_info_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubFromGo.topic_info_list)
  return _internal_topic_info_list();
}
inline ::com::geotab::ioxproto::TopicInfoList* PubSubFromGo::unsafe_arena_release_topic_info_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubFromGo.topic_info_list)
  if (msg_case() == kTopicInfoList) {
    clear_has_msg();
    auto* temp = _impl_.msg_.topic_info_list_;
    _impl_.msg_.topic_info_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubFromGo::unsafe_arena_set_allocated_topic_info_list(::com::geotab::ioxproto::TopicInfoList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_topic_info_list();
    _impl_.msg_.topic_info_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubFromGo.topic_info_list)
}
inline ::com::geotab::ioxproto::TopicInfoList* PubSubFromGo::_internal_mutable_topic_info_list() {
  if (msg_case() != kTopicInfoList) {
    clear_msg();
    set_has_topic_info_list();
    _impl_.msg_.topic_info_list_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::TopicInfoList>(GetArena());
  }
  return _impl_.msg_.topic_info_list_;
}
inline ::com::geotab::ioxproto::TopicInfoList* PubSubFromGo::mutable_topic_info_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::TopicInfoList* _msg = _internal_mutable_topic_info_list();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubFromGo.topic_info_list)
  return _msg;
}

// .com.geotab.ioxproto.Publish pub = 4;
inline bool PubSubFromGo::has_pub() const {
  return msg_case() == kPub;
}
inline bool PubSubFromGo::_internal_has_pub() const {
  return msg_case() == kPub;
}
inline void PubSubFromGo::set_has_pub() {
  _impl_._oneof_case_[0] = kPub;
}
inline void PubSubFromGo::clear_pub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kPub) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.pub_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.pub_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::Publish* PubSubFromGo::release_pub() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubFromGo.pub)
  if (msg_case() == kPub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pub_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.pub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::Publish& PubSubFromGo::_internal_pub() const {
  return msg_case() == kPub ? *_impl_.msg_.pub_ : reinterpret_cast<::com::geotab::ioxproto::Publish&>(::com::geotab::ioxproto::_Publish_default_instance_);
}
inline const ::com::geotab::ioxproto::Publish& PubSubFromGo::pub() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubFromGo.pub)
  return _internal_pub();
}
inline ::com::geotab::ioxproto::Publish* PubSubFromGo::unsafe_arena_release_pub() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubFromGo.pub)
  if (msg_case() == kPub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pub_;
    _impl_.msg_.pub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubFromGo::unsafe_arena_set_allocated_pub(::com::geotab::ioxproto::Publish* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_pub();
    _impl_.msg_.pub_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubFromGo.pub)
}
inline ::com::geotab::ioxproto::Publish* PubSubFromGo::_internal_mutable_pub() {
  if (msg_case() != kPub) {
    clear_msg();
    set_has_pub();
    _impl_.msg_.pub_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::Publish>(GetArena());
  }
  return _impl_.msg_.pub_;
}
inline ::com::geotab::ioxproto::Publish* PubSubFromGo::mutable_pub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::Publish* _msg = _internal_mutable_pub();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubFromGo.pub)
  return _msg;
}

// .com.geotab.ioxproto.ClearSubsAck clear_subs_ack = 5;
inline bool PubSubFromGo::has_clear_subs_ack() const {
  return msg_case() == kClearSubsAck;
}
inline bool PubSubFromGo::_internal_has_clear_subs_ack() const {
  return msg_case() == kClearSubsAck;
}
inline void PubSubFromGo::set_has_clear_subs_ack() {
  _impl_._oneof_case_[0] = kClearSubsAck;
}
inline void PubSubFromGo::clear_clear_subs_ack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kClearSubsAck) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.clear_subs_ack_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.clear_subs_ack_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::ClearSubsAck* PubSubFromGo::release_clear_subs_ack() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.PubSubFromGo.clear_subs_ack)
  if (msg_case() == kClearSubsAck) {
    clear_has_msg();
    auto* temp = _impl_.msg_.clear_subs_ack_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.clear_subs_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::ClearSubsAck& PubSubFromGo::_internal_clear_subs_ack() const {
  return msg_case() == kClearSubsAck ? *_impl_.msg_.clear_subs_ack_ : reinterpret_cast<::com::geotab::ioxproto::ClearSubsAck&>(::com::geotab::ioxproto::_ClearSubsAck_default_instance_);
}
inline const ::com::geotab::ioxproto::ClearSubsAck& PubSubFromGo::clear_subs_ack() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.PubSubFromGo.clear_subs_ack)
  return _internal_clear_subs_ack();
}
inline ::com::geotab::ioxproto::ClearSubsAck* PubSubFromGo::unsafe_arena_release_clear_subs_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.PubSubFromGo.clear_subs_ack)
  if (msg_case() == kClearSubsAck) {
    clear_has_msg();
    auto* temp = _impl_.msg_.clear_subs_ack_;
    _impl_.msg_.clear_subs_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PubSubFromGo::unsafe_arena_set_allocated_clear_subs_ack(::com::geotab::ioxproto::ClearSubsAck* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_clear_subs_ack();
    _impl_.msg_.clear_subs_ack_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.PubSubFromGo.clear_subs_ack)
}
inline ::com::geotab::ioxproto::ClearSubsAck* PubSubFromGo::_internal_mutable_clear_subs_ack() {
  if (msg_case() != kClearSubsAck) {
    clear_msg();
    set_has_clear_subs_ack();
    _impl_.msg_.clear_subs_ack_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::ClearSubsAck>(GetArena());
  }
  return _impl_.msg_.clear_subs_ack_;
}
inline ::com::geotab::ioxproto::ClearSubsAck* PubSubFromGo::mutable_clear_subs_ack() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::ClearSubsAck* _msg = _internal_mutable_clear_subs_ack();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.PubSubFromGo.clear_subs_ack)
  return _msg;
}

inline bool PubSubFromGo::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void PubSubFromGo::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline PubSubFromGo::MsgCase PubSubFromGo::msg_case() const {
  return PubSubFromGo::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IoxToGo

// .com.geotab.ioxproto.PubSubToGo pub_sub = 1;
inline bool IoxToGo::has_pub_sub() const {
  return msg_case() == kPubSub;
}
inline bool IoxToGo::_internal_has_pub_sub() const {
  return msg_case() == kPubSub;
}
inline void IoxToGo::set_has_pub_sub() {
  _impl_._oneof_case_[0] = kPubSub;
}
inline void IoxToGo::clear_pub_sub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kPubSub) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.pub_sub_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.pub_sub_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::PubSubToGo* IoxToGo::release_pub_sub() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.IoxToGo.pub_sub)
  if (msg_case() == kPubSub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pub_sub_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.pub_sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::PubSubToGo& IoxToGo::_internal_pub_sub() const {
  return msg_case() == kPubSub ? *_impl_.msg_.pub_sub_ : reinterpret_cast<::com::geotab::ioxproto::PubSubToGo&>(::com::geotab::ioxproto::_PubSubToGo_default_instance_);
}
inline const ::com::geotab::ioxproto::PubSubToGo& IoxToGo::pub_sub() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.IoxToGo.pub_sub)
  return _internal_pub_sub();
}
inline ::com::geotab::ioxproto::PubSubToGo* IoxToGo::unsafe_arena_release_pub_sub() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.IoxToGo.pub_sub)
  if (msg_case() == kPubSub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pub_sub_;
    _impl_.msg_.pub_sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IoxToGo::unsafe_arena_set_allocated_pub_sub(::com::geotab::ioxproto::PubSubToGo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_pub_sub();
    _impl_.msg_.pub_sub_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.IoxToGo.pub_sub)
}
inline ::com::geotab::ioxproto::PubSubToGo* IoxToGo::_internal_mutable_pub_sub() {
  if (msg_case() != kPubSub) {
    clear_msg();
    set_has_pub_sub();
    _impl_.msg_.pub_sub_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::PubSubToGo>(GetArena());
  }
  return _impl_.msg_.pub_sub_;
}
inline ::com::geotab::ioxproto::PubSubToGo* IoxToGo::mutable_pub_sub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::PubSubToGo* _msg = _internal_mutable_pub_sub();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.IoxToGo.pub_sub)
  return _msg;
}

inline bool IoxToGo::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void IoxToGo::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline IoxToGo::MsgCase IoxToGo::msg_case() const {
  return IoxToGo::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IoxFromGo

// .com.geotab.ioxproto.PubSubFromGo pub_sub = 1;
inline bool IoxFromGo::has_pub_sub() const {
  return msg_case() == kPubSub;
}
inline bool IoxFromGo::_internal_has_pub_sub() const {
  return msg_case() == kPubSub;
}
inline void IoxFromGo::set_has_pub_sub() {
  _impl_._oneof_case_[0] = kPubSub;
}
inline void IoxFromGo::clear_pub_sub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (msg_case() == kPubSub) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.pub_sub_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.msg_.pub_sub_);
    }
    clear_has_msg();
  }
}
inline ::com::geotab::ioxproto::PubSubFromGo* IoxFromGo::release_pub_sub() {
  // @@protoc_insertion_point(field_release:com.geotab.ioxproto.IoxFromGo.pub_sub)
  if (msg_case() == kPubSub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pub_sub_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.pub_sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::com::geotab::ioxproto::PubSubFromGo& IoxFromGo::_internal_pub_sub() const {
  return msg_case() == kPubSub ? *_impl_.msg_.pub_sub_ : reinterpret_cast<::com::geotab::ioxproto::PubSubFromGo&>(::com::geotab::ioxproto::_PubSubFromGo_default_instance_);
}
inline const ::com::geotab::ioxproto::PubSubFromGo& IoxFromGo::pub_sub() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:com.geotab.ioxproto.IoxFromGo.pub_sub)
  return _internal_pub_sub();
}
inline ::com::geotab::ioxproto::PubSubFromGo* IoxFromGo::unsafe_arena_release_pub_sub() {
  // @@protoc_insertion_point(field_unsafe_arena_release:com.geotab.ioxproto.IoxFromGo.pub_sub)
  if (msg_case() == kPubSub) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pub_sub_;
    _impl_.msg_.pub_sub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IoxFromGo::unsafe_arena_set_allocated_pub_sub(::com::geotab::ioxproto::PubSubFromGo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_pub_sub();
    _impl_.msg_.pub_sub_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.geotab.ioxproto.IoxFromGo.pub_sub)
}
inline ::com::geotab::ioxproto::PubSubFromGo* IoxFromGo::_internal_mutable_pub_sub() {
  if (msg_case() != kPubSub) {
    clear_msg();
    set_has_pub_sub();
    _impl_.msg_.pub_sub_ =
        ::google::protobuf::Message::DefaultConstruct<::com::geotab::ioxproto::PubSubFromGo>(GetArena());
  }
  return _impl_.msg_.pub_sub_;
}
inline ::com::geotab::ioxproto::PubSubFromGo* IoxFromGo::mutable_pub_sub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::com::geotab::ioxproto::PubSubFromGo* _msg = _internal_mutable_pub_sub();
  // @@protoc_insertion_point(field_mutable:com.geotab.ioxproto.IoxFromGo.pub_sub)
  return _msg;
}

inline bool IoxFromGo::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void IoxFromGo::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline IoxFromGo::MsgCase IoxFromGo::msg_case() const {
  return IoxFromGo::MsgCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ioxproto
}  // namespace geotab
}  // namespace com


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::com::geotab::ioxproto::SubAck_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::geotab::ioxproto::SubAck_Result>() {
  return ::com::geotab::ioxproto::SubAck_Result_descriptor();
}
template <>
struct is_proto_enum<::com::geotab::ioxproto::ClearSubsAck_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::geotab::ioxproto::ClearSubsAck_Result>() {
  return ::com::geotab::ioxproto::ClearSubsAck_Result_descriptor();
}
template <>
struct is_proto_enum<::com::geotab::ioxproto::Topic> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::com::geotab::ioxproto::Topic>() {
  return ::com::geotab::ioxproto::Topic_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_iox_5fmessaging_2eproto_2epb_2eh
